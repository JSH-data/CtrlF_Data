# Prim's algorithm
- Greedy Approach를 따르는 Minimal Spanning Tree를 구하는 알고리즘

## Prim's algorithm의 동작
1. 하나의 정점으로부터 시작된다
2. 앞 단계에서 만들어진 트리에서 가중치가 가장 낮은 간선을 추가해 최종적으로 MST에 도달한다

## Prim's algorithm의 예
![test](./image1.png)

- Graph (V, F)로 부터 MST를 찾는 과정
1. 임의의 정점(node)을 정한다 (V1) (두번째 그래프 참조)
   - V = { V&#8321; }, F = Ø
2. 정점에서 가장 가중치가 낮은 간선(egde)을 연결한다 (세번째 그래프 참조)
   - V = { V&#8321;, V&#8322; }, F = { (V&#8321; - V&#8322;) }
3. set V 에서 연결할 수 있는 가중치가 가장 낮은 간선(egde)을 연결한다. (세번 째 그래프 참조)
   - 이 경우 (V₁ - V&#8323;), (V&#8322; - V&#8323;), (V&#8322; - V&#8324;) 중 한개를 선택 할 수 있는데, 가장 짧은 간선 중 하나인 (V₁ - V&#8323;) 선택
   - V = { V&#8321;, V&#8322;, V&#8323; }, F = { (V&#8321; - V&#8322;), (V&#8321; - V&#8323;) }
4. 이후의 과정도 위와 같은 방식으로 set V의 요소들 중 연결할 수 있는 가장 작은 간선을 연결하여 MST에 도달한다 (여섯 째 그래프 참조)
   - V = { V&#8321;, V&#8322;, V&#8323;, V&#8324;, V&#8325; }, F = { (V&#8321; - V&#8322;), (V&#8321; - V&#8323;), (V&#8323; - V&#8324;), (V&#8323; - V&#8325;) }

## Prim's algorithm의 시간복잡도
- 정점(node)의 수 (n - 1) (초기 정점 V&#8321; 제외), 정점 당 연결 될 수 있는 간선의 수 (n - 1)만큼 반복
  - 시간 복잡도 : (n - 1) * (n - 1) ∈ O(n&#178;)